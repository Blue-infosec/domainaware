#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""A dnstwist and/or URLCrazy wrapper for emailing security staff when possible typo sqatting/spear
phishing domains have been registered"""

from configparser import ConfigParser
from argparse import ArgumentParser
from os import path, getcwd
from subprocess import check_output, PIPE
from sys import stderr
from io import StringIO
from csv import DictReader, DictWriter

from requests import get
from marrow.mailer import Mailer, Message

__author__ = 'Sean Whalen'
__version__ = '1.1.2'


def dt_whois(domain, **kwargs):
    """Returns WHOIS data from DomainTools"""
    user_agent = "domainalert/{}".format(__version__)
    headers = {"User-Agent": user_agent}
    params = dict(api_username=kwargs["api_username"], api_key=kwargs["api_key"])
    url = "https://api.domaintools.com/v1/{}/whois".format(domain)
    if kwargs["parsed_whois"].lower() == "true":
        url += "/parsed"
    response = get(url, headers=headers, params=params)
    if response.status_code == 403:
        raise RuntimeError("DomainTools authentication failed")
    if response.status_code == 404:
        return dict()
    return response.json()["response"]


def get_row_domain(row):
    """Used as the key for sorting CSV rows by domain"""
    return row['Domain']


def convert_country(name):
    """Converts a country name from urlcrazy format to dnstwist format"""
    words = name.split(" ")
    for i in range(len(words)):
        words[i] = words[i].lower().title()
    name = " ".join(words)

    return name


def crazy_twist(crazy_row):
    """Converts a urlcrazy row to dnstwist format"""
    fuzzer_map = {
        "Character Omission": "Omission",
        "Character Repeat": "Repetition",
        "Character Swap": "Transposition",
        "Character Replacement": "Replacement",
        "Character Insertion": "Insertion",
        "Common Misspelling": "Misspelling",
        "Bit Flipping": "Bitsquatting",
        "Homoglyphs": "Homoglyph",
        "Wrong SLD": "Subdomain"
    }

    fuzzer = crazy_row["Typo Type"]
    if fuzzer in fuzzer_map:
        fuzzer = fuzzer_map[fuzzer]

    if crazy_row["DNS-A"] == "?":
        crazy_row["DNS-A"] = None

    twist_row = {
        "Fuzzer": fuzzer,
        "Domain": crazy_row["Typo"],
        "A": crazy_row["DNS-A"],
        "MX": crazy_row["DNS-MX"]
    }

    if crazy_row['Country-A']:
        twist_row['Country'] = convert_country(crazy_row["Country-A"])

    return twist_row


def twist_query(dnstwist_path, domain):
    """Query dnstwist"""
    rows = []
    dt_args = [dnstwist_path, '-grc', domain]
    output = check_output(dt_args, universal_newlines=True, stderr=PIPE)
    dnstwist_csv = DictReader(StringIO(str(output)))
    try:
        next(dnstwist_csv)
    # skip first row; it contains original domain
    except StopIteration:
        return []
    for row in dnstwist_csv:
        del row["SSDEEP"]
        rows.append(row)

    return rows


def crazy_query(urlcrazy_path, domain, attempt=1):
    """Query URLCrazy"""
    max_attempts = 3
    rows = []
    dt_args = [urlcrazy_path, '-f', 'csv', domain]
    try:
        output = check_output(dt_args, universal_newlines=True, stderr=PIPE)
        output = str(output)
        output = output.replace('\0', '')
    except (UnicodeDecodeError, ProcessLookupError, ChildProcessError):
        attempt += 1
        if attempt > max_attempts:
            print("Warning: Failed to parse URLCrazy output for {}".format(domain), file=stderr)
            return []

        return crazy_query(urlcrazy_path, domain)

    urlcrazy_csv = DictReader(StringIO(output, newline=''))
    for row in urlcrazy_csv:
        rows.append(crazy_twist(row))

    return rows


def add_dt(rows, **kwargs):
    """Add WHOIS information from DomainTools to the CSV rows"""
    for row in rows:
        whois = dt_whois(row['Domain'], **kwargs)
        if 'registrant' in whois:
            row["Registrant"] = whois["registrant"]
        if 'registration' in whois:
            if 'registrar' in whois['registration']:
                row["Registrar"] = whois['registration']["registrar"]
            if 'created' in whois['registration']:
                row["Created"] = whois['registration']["created"]
            if 'updated' in whois['registration']:
                row["Updated"] = whois['registration']["updated"]
            if 'expires' in whois['registration']:
                row["Expires"] = whois['registration']["expires"]

    return rows


def find_new_domains(tool_paths, my_domains_path, known_domains_path, **kwargs):
    """"Returns suspicious domain information as a list of dictionaries"""
    known_domains = []
    new_domains = []
    with open(known_domains_path, 'r') as known_domains_file:
        known_domains_csv = DictReader(known_domains_file)
        for row in known_domains_csv:
            known_domains.append(row["Domain"])

    with open(my_domains_path, 'rU') as my_domains:
        for my_domain in my_domains:
            my_domain = my_domain.strip().lower()
            if tool_paths["dnstwist"]:
                for row in twist_query(tool_paths["dnstwist"], my_domain):
                    if row['Domain'] not in known_domains:
                        new_domains.append(row)

            if tool_paths["urlcrazy"]:
                for row in crazy_query(tool_paths["urlcrazy"], my_domain):
                    if row["A"] == "":
                        continue
                    if row['Domain'] not in known_domains and row['Domain'] not in new_domains:
                        new_domains.append(row)

    if kwargs["api_username"] and kwargs["api_key"]:
        new_domains = add_dt(new_domains, kwargs)

    return sorted(new_domains, key=get_row_domain)


def generate_output(results, config_directory, output_path):
    """"PWrites output files"""
    domains = []
    # write out results
    # this file will only contain the header if there are no new results
    with open(output_path, 'w') as outfile:
        fieldnames = ['Fuzzer', 'Domain', 'Registrant', 'Registrar', 'Created', 'Updated', 'Expires',
                      'A', 'AAAA', 'MX', 'NS', 'Country']
        writer = DictWriter(outfile, fieldnames=fieldnames)
        writer.writeheader()
        for row in results:
            domains.append(row['Domain'])
            writer.writerow(row)
    outfile.close()

    with open(path.join(config_directory, "last_domains"), "w") as last_domains_file:
        last_domains_file.writelines(domains)


def send_mail(**kwargs):
    """Sends an email message"""
    mailer_config = {
        'manager.use': 'immediate',
        'transport.use': 'smtp',
        'transport.host': kwargs['host'],
    }

    if kwargs["port"]:
        mailer_config["transport.port"] = kwargs["port"]
    if kwargs["username"]:
        mailer_config["transport.username"] = kwargs["username"]
    if kwargs["password"]:
        mailer_config["transport.password"] = kwargs["password"]

    mailer = Mailer(mailer_config)
    mailer.start()

    message = Message(author=kwargs['from'], to=kwargs["to"].split(", "))
    message.subject = kwargs["subject"]
    message.plain = kwargs["body"]

    if "files" in kwargs:
        for file_path in kwargs['files']:
            message.attach(file_path)

    mailer.send(message)

    mailer.stop()


def mail_report(output_file_path, **kwargs):
    """Mail the report"""
    num_lines = 0
    num_domains = 0
    with open(output_file_path, 'rbU') as output_file:
        for line in output_file:
            num_lines += 1
            num_domains = num_lines - 1  # Ignore CSV header in count
    if num_domains > 0:
        kwargs["files"] = [output_file_path]
        kwargs["body"] = kwargs["new_results_body"]
    else:
        kwargs["body"] = kwargs["no_new_results_body"]

    send_mail(**kwargs)


def main():
    """Called when the module is executed rather than imported"""
    parser = ArgumentParser(prog='domainaware',
                            description=__doc__)
    parser.add_argument('-c', '--config',
                        help='Directory location for required config files; defaults to the current working directory',
                        default=getcwd(),
                        required=False)
    parser.add_argument('-o', '--output', help='Path to output to; defaults to results.csv', default='results.csv',
                        required=False)
    parser.add_argument('-m', '--email', help='Email results upon completion; defaults to False', action="store_true",
                        default=False, required=False)

    args = parser.parse_args()

    if not path.isdir(args.config):
        print("ERROR! Specified configuration directory {} does not exist!".format(args.config))
        exit(-1)

    config_file_path = path.join(args.config, "settings.cfg")
    if not path.exists(config_file_path):
        print("ERROR! {} does not exist!".format(config_file_path))
        exit(-1)

    output_path = args.output
    my_domains_path = path.join(args.config, 'mydomains.csv')
    known_domains_path = path.join(args.config, 'knowndomains.csv')

    config = ConfigParser(allow_no_value=True)
    config.read([config_file_path])

    paths_config = dict(config.items("paths"))
    email_config = dict(config.items("email"))
    email_config["results_file"] = output_path
    dt_config = dict(config.items("domaintools"))

    last_domains_path = path.join(args.config, "last_domains")
    stale = True
    if path.exists(last_domains_path):
        with open(last_domains_path) as last_domains_file:
            last_domains = last_domains_file.readlines()
        with open(known_domains_path) as known_csv:
            csv_reader = DictReader(known_csv)
            for csv_row in csv_reader:
                if csv_row['Domain'] not in last_domains:
                    stale = False
                    break
    else:
        stale = False

    if stale:
        if args.email:
            email_config["body"] = email_config["stale_body"]
            send_mail(**email_config)
            exit(2)

    results = find_new_domains(paths_config, my_domains_path, known_domains_path, **dt_config)

    generate_output(results, args.config, output_path)

    if args.email:
        mail_report(args.output, **email_config)

if __name__ == "__main__":
    main()
