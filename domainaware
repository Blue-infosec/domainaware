#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""A dnstwist wrapper for emailing security staff when possible typo sqatting/spear
phishing domains have been registered"""

from ConfigParser import ConfigParser
from argparse import ArgumentParser
from os import path, getcwd
from subprocess import check_output, PIPE
from StringIO import StringIO
from unicodecsv import DictReader, DictWriter

from requests import get
from marrow.mailer import Mailer, Message

__author__ = 'Sean Whalen'
__version__ = '1.0.1'


def dt_whois(domain, **kwargs):
    """Returns WHOIS data from DomainTools"""
    user_agent = "domainalert/{}".format(__version__)
    headers = {"User-Agent": user_agent}
    params = dict(api_username=kwargs["api_username"], api_key=kwargs["api_key"])
    url = "https://api.domaintools.com/v1/{}/whois".format(domain)
    if kwargs["parsed_whois"].lower() == "true":
        url += "/parsed"
    response = get(url, headers=headers, params=params)
    if response.status_code == 403:
        raise RuntimeError("DomainTools authentication failed")
    if response.status_code == 404:
        return dict()
    return response.json()["response"]


def get_row_domain(row):
    """Used as the key for sorting CSV rows by domain"""
    return row['Domain']


def find_new_domains(dnstwist_path, my_domains_path, known_domains_path, **kwargs):
    """"Returns suspicious domain information as a list of dictionaries"""
    new_domains = []
    with open(known_domains_path, 'rbU') as known_domains_file:
        known_domains = known_domains_file.readlines()

    with open(my_domains_path, 'rbU') as domains:
        for domain in domains:
            domain = domain.strip()
            dt_args = [dnstwist_path, '-grc', domain]
            output = check_output(dt_args, stderr=PIPE)
            new_domains_csv = DictReader(StringIO(output))
            try:
                # skip first row; it contains original domain
                next(new_domains_csv)
            except StopIteration:
                continue  # There were no results for that domain
            for row in new_domains_csv:
                if row['Domain'] not in known_domains:
                    if kwargs["api_username"] and kwargs["api_key"]:
                        whois = dt_whois(row['Domain'], **kwargs)
                        if 'registrant' in whois:
                            row["Registrant"] = whois["registrant"]
                        if 'registration' in whois:
                            if 'registrar' in whois['registration']:
                                row["Registrar"] = whois['registration']["registrar"]
                            if 'created' in whois['registration']:
                                row["Created"] = whois['registration']["created"]
                            if 'updated' in whois['registration']:
                                row["Updated"] = whois['registration']["updated"]
                            if 'expires' in whois['registration']:
                                row["Expires"] = whois['registration']["expires"]
                    new_domains.append(row)

    return sorted(new_domains, key=get_row_domain)


def generate_output(results, config_directory, output_path):
    """"PWrites output files"""
    domains = []
    # write out results
    # this file will only contain the header if there are no new results
    with open(output_path, 'wb') as outfile:
        fieldnames = ['Fuzzer', 'Domain', 'Registrant', 'Registrar', 'Created', 'Updated', 'Expires',
                      'A', 'AAAA', 'MX', 'NS', 'Country', 'SSDEEP']
        writer = DictWriter(outfile, fieldnames=fieldnames)
        writer.writeheader()
        for row in results:
            domains.append(row['Domain'])
            writer.writerow(row)
    outfile.close()

    with open(path.join(config_directory, "last_domains"), "w") as last_domains_file:
        last_domains_file.writelines(domains)


def send_mail(**kwargs):
    """Sends an email message"""
    mailer_config = {
        'manager.use': 'immediate',
        'transport.use': 'smtp',
        'transport.host': kwargs['host'],
    }

    if kwargs["port"]:
        mailer_config["transport.port"] = kwargs["port"]
    if kwargs["username"]:
        mailer_config["transport.username"] = kwargs["username"]
    if kwargs["password"]:
        mailer_config["transport.password"] = kwargs["password"]

    mailer = Mailer(mailer_config)
    mailer.start()

    message = Message(author=kwargs['from'], to=kwargs["to".split(", ")])
    message.subject = kwargs["subject"]
    message.plain = kwargs["body"]

    for file_path in kwargs['files']:
        message.attach(file_path)

    mailer.send(message)

    mailer.stop()


def mail_report(output_file_path, **kwargs):
    """Mail the report"""
    num_lines = 0
    num_domains = 0
    with open(output_file_path, 'rbU') as output_file:
        for line in output_file:
            num_lines += 1
            num_domains = num_lines - 1  # Ignore CSV header in count
    if num_domains > 0:
        kwargs["files"] = [output_file_path]
        kwargs["body"] = kwargs["new_results_body"]
    else:
        kwargs["body"] = kwargs["no_new_results_body"]

    send_mail(**kwargs)


def main():
    """Called when the module is executed rather than imported"""
    parser = ArgumentParser(prog='domainaware',
                            description=__doc__,
                            version=__version__, add_help=True)
    parser.add_argument('-c', '--config',
                        help='Directory location for required config files; defaults to the current working directory',
                        default=getcwd(),
                        required=False)
    parser.add_argument('-o', '--output', help='Path to output to; defaults to results.csv', default='results.csv',
                        required=False)
    parser.add_argument('-m', '--email', help='Email results upon completion; defaults to False', action="store_true",
                        default=False, required=False)

    args = parser.parse_args()

    if not path.isdir(args.config):
        print "ERROR! Specified configuration directory {} does not exist!".format(args.config)
        exit(-1)

    config_file_path = path.join(args.config, "settings.cfg")
    if not path.exists(config_file_path):
        print("ERROR! {} does not exist!".format(config_file_path))
        exit(-1)

    output_path = args.output
    my_domains_path = path.join(args.config, 'mydomains.csv')
    known_domains_path = path.join(args.config, 'knowndomains.csv')

    config = ConfigParser(allow_no_value=True)
    config.read([config_file_path])

    paths_config = dict(config.items("paths"))
    email_config = dict(config.items("email"))
    email_config["results_file"] = output_path
    dt_config = dict(config.items("domaintools"))

    last_domains_path = path.join(args.config, "last_domains")
    stale = True
    if path.exists(last_domains_path):
        with open(last_domains_path) as last_domains_file:
            last_domains = last_domains_file.readlines()
        with open(known_domains_path) as known_csv:
            csv_reader = DictReader(known_csv)
            for csv_row in csv_reader:
                if csv_row['Domain'] not in last_domains:
                    stale = False
                    break
    else:
        stale = False

    if stale:
        if args.email:
            email_config["body"] = email_config["stale_body"]
            send_mail(**email_config)
            exit(2)

    results = find_new_domains(paths_config['dnstwist'], my_domains_path, known_domains_path, **dt_config)

    generate_output(results, args.config, output_path)

    if args.email:
        mail_report(args.output, **email_config)

if __name__ == "__main__":
    main()
